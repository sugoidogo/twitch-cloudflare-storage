import localforage from 'https://cdn.jsdelivr.net/npm/localforage/+esm'

function getURL(path,isPublic){
    const url=new URL(path,import.meta.url)
    url.searchParams.append('public',isPublic)
    return url
}

function toDataURL(blob){
    return new Promise((resolve,reject)=>{
        const fileReader=new FileReader()
        fileReader.onload=(event)=>resolve(event.target.result)
        fileReader.onabort=(event)=>reject(event)
        fileReader.onerror=(event)=>reject(event)
        fileReader.readAsDataURL(blob)
    })
}

export default class {
    constructor(authProvider){
        this.authProvider=authProvider
        /** @type {Storage} */
        this.privateStorage=localforage.createInstance({name:'private.'+authProvider.clientId+'.'+import.meta.url})
        /** @type {Storage} */
        this.publicStorage=localforage.createInstance({name:'public.'+authProvider.clientId+'.'+import.meta.url})
    }

    async getHeaders(){
        const token=await this.authProvider.getAnyAccessToken()
        return {authorization:'OAuth '+token.accessToken}
    }

    getStorage(isPublic){
        if(isPublic){
            return this.publicStorage
        }else{
            return this.privateStorage
        }
    }

    async get(path,isPublic=false){
        const url=getURL(path,isPublic)
        const storage=this.getStorage(isPublic)

        return fetch(url,{headers:await this.getHeaders()}).then(async response=>{
            if(!response.ok){
                throw 'failed to fetch'
            }else{
                response.clone().blob().then(blob=>{
                    return toDataURL(blob)
                }).then(dataURL=>{
                    storage.setItem(path,dataURL)
                })
                return response
            }
        }).catch(async ()=>{
            const data=await storage.getItem(path)
            if(!data){
                return new Response(null,{status:404})
            }else{
                return fetch(data)
            }
        })
    }

    async put(path,data,isPublic=false){
        const url=getURL(path,isPublic)
        const storage=this.getStorage(isPublic)

        if(!(data instanceof Blob)){
            data=new Blob([data])
        }
        data=await toDataURL(data)

        storage.setItem(path,data)
        return fetch(url,{method:'PUT',body:data,headers:await this.getHeaders()})
    }

    async delete(path,isPublic=false){
        const url=getURL(path,isPublic)
        const storage=this.getStorage(isPublic)

        storage.removeItem(path)//TODO the server is recursive, but this library is not
        return fetch(url,{method:'DELETE',headers:await this.getHeaders()})
    }

    reset(){
        this.privateStorage.clear()
        this.publicStorage.clear()
    }

    async sync(isPublic){
        await fetch(getURL('/',isPublic),{method:'DELETE',headers:await this.getHeaders()})
        const storage=this.getStorage(isPublic)
        const promises=[]
        for(let i;i<storage.length;i++){
            const path=storage.key(i)
            const data=await storage.getItem(path)
            const url=getURL(path,isPublic)
            let promise=fetch(url,{method:'POST',headers:await this.getHeaders(),data:data})
            promises.push(promise)
        }
        return promises
    }

    async sync(){
        return Promise.all(this.sync(true),this.sync(false))
    }

}